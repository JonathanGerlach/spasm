// File is autogenerated with `dub run spasm:webpack-bootstrap`
const abort = (what,file,line) => {
    throw `ABORT: $what @ $file:$line`;
}

const utf8Decoder = new TextDecoder('utf-8');
const utf8Encoder = new TextEncoder();
const memory = new WebAssembly.Memory({initial:16*16, maximum:16*16});

let lastPtr = 3;
let objects = {1: document, 2: window};
let buffer = memory.buffer,
    addPrimitive = (value) => {
        if (value === null || value == undefined) return 0;
        objects[++lastPtr] = value;
        return lastPtr;
    };
const spasm = {
    memory: memory,
    heapi32s: new Int32Array(buffer),
    heapi32u: new Uint32Array(buffer),
    heapi16s: new Int16Array(buffer),
    heapi16u: new Uint16Array(buffer),
    heapi8s: new Int8Array(buffer),
    heapi8u: new Uint8Array(buffer),
    heapf32: new Float32Array(buffer),
    heapf64: new Float64Array(buffer),
    instance: null,
    init: (modules) => {
        let exports = {env: Object.assign.apply(null,modules.map(m=>m.jsExports).filter(a=>!!a))};
        WebAssembly.instantiateStreaming(fetch('@@targetProjectName@@'), exports)
            .then(obj => {
                spasm.instance = obj.instance;
                obj.instance.exports._start();
            });
    },
    objects,
    addObject: (obj) => {
        if (obj === null || obj === undefined) return 0;
        if (obj.wasmPtr !== undefined) return obj.wasmPtr;
        objects[++lastPtr] = obj;
        obj.wasmId = lastPtr;
        return lastPtr;
    },
}

let encoders = {
    string: (ptr, val) => {
        const encodedString = utf8Encoder.encode(val);
        const wasmPtr = spasm.instance.exports.allocString(encodedString.length);
        const asBytes = new Uint8Array(buffer, wasmPtr, encodedString.length);
        spasm.heapi32u[u8ptr / 4] = encodedString.length;
        spasm.heapi32u[(u8ptr / 4)+1] = wasmPtr;
        asBytes.set(encodedString);
        return u8ptr;
    }
}
let decoders = {
    string: (len, offset) => {
        if (offset == null) {
            offset = spasm.heapi32u[(len+4)/4];
            len = spasm.heapi32u[(len/4)];
        }
        return utf8Decoder.decode(new DataView(buffer,offset,len));
    }
}
let jsExports = {
    onOutOfMemoryError: () => abort("Out of memory exception"),
    _d_assert: (file,line) => abort("assert",file,line),
    doLog: arg => console.log(arg),
    memory: spasm.memory,
    __assert: () => {},
    _Unwind_Resume: () => {
        console.log(arguments);
    },
    _d_dynamic_cast: () => {
        console.log(arguments)
    },
    spasm_add__bool: (b)=>addPrimitive(!!b),
    spasm_add__int: addPrimitive,
    spasm_add__uint: addPrimitive,
    spasm_add__long: addPrimitive,
    spasm_add__ulong: addPrimitive,
    spasm_add__short: addPrimitive,
    spasm_add__ushort: addPrimitive,
    spasm_add__byte: addPrimitive,
    spasm_add__ubyte: addPrimitive,
    spasm_add__float: addPrimitive,
    spasm_add__double: addPrimitive,
    spasm_add__object: () => addPrimitive({}),
    spasm_add__string: (len, offset) => {
        return addPrimitive(decoders.string(len, offset));
    },
    spasm_removeObject: (ctx) => {
        delete objects[ctx]
    }
};

export {spasm, encoders, decoders, jsExports};
